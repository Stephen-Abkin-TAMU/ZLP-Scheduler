#!/usr/bin/env python3"""Made by Stephen Abkin - Class of 2027 (Cohort J)schedule.py — detect section conflicts and list 100‑minute time blocks,with support for lab identifiers (e.g. ECEN 214L”).• Lecture:  MEEN 221  MWF 09:10 50• Lab:      ECEN 214L R   15:00 170"""from __future__ import annotationsimport refrom typing import Dict, List, Tuple# ───────────────────────────────── constants ──────────────────────────────DAY_LETTERS = "MTWRF"DAY_NAMES   = {    "M": "Monday", "T": "Tuesday", "W": "Wednesday",    "R": "Thursday", "F": "Friday"}CLASS_MIN_START, CLASS_MAX_START = 8 * 60, 16 * 60 + 10   # 08:00–16:10SLOT_MAX_START                   = 17 * 60                # study‑slot start ≤ 17:00BLOCK_LEN = 100                  # 100‑minute window lengthSTEP_MIN  = 5                    # 5‑minute gridCRS_RE  = re.compile(r"^[A-Z]{4}$")#        (below)  three digits, optional trailing 'L' or 'l'NUM_RE  = re.compile(r"^\d{3}[Ll]?$")            # <─── CHANGEDTIME_RE = re.compile(r"^(2[0-3]|1\d|0\d):([0-5]\d)$")DAYS_RE = re.compile(r"^[MTWRF]+$", re.I)# ───────────────────────────────── helpers ────────────────────────────────def to_minutes(hhmm: str) -> int:    return int(hhmm[:2]) * 60 + int(hhmm[3:])def to_hhmm(m: int) -> str:    return f"{m//60:02d}:{m%60:02d}"def overlaps(a: Tuple[int, int], b: Tuple[int, int]) -> bool:    return max(a[0], b[0]) < min(a[1], b[1])def merge(intvs: List[Tuple[int, int]]) -> List[Tuple[int, int]]:    out = []    for s, e in sorted(intvs):        if not out or s > out[-1][1]:            out.append([s, e])        else:            out[-1][1] = max(out[-1][1], e)    return outdef free_and_min_conflict_slots(busy_day: List[Tuple[int, int]]                                ) -> Tuple[List[Tuple[int, int]], List[int], int]:    free, best, min_cnt = [], [], float('inf')    for start in range(CLASS_MIN_START, SLOT_MAX_START + 1, STEP_MIN):        block = (start, start + BLOCK_LEN)        cnt = sum(1 for iv in busy_day if overlaps(block, iv))        if cnt == 0:            free.append(block)        if cnt < min_cnt:            min_cnt, best = cnt, [start]        elif cnt == min_cnt:            best.append(start)    return free, best, min_cnt# ───────────────────────── interactive main routine ───────────────────────def main() -> None:    sections: Dict[str, List[Tuple[str, int, int, str]]] = {}    print(        "\nEnter every section you’re considering:"        "\n  <SUBJ> <NUM|NUML> <DAYS> <HH:MM> <DURATION>"        "\nExamples:"        "\n  MEEN 221  MWF 09:10 50"        "\n  ECEN 214L R   15:00 170"        "\nType 'done' when finished.\n"    )    while True:        line = input("> ").strip()        if line.lower() == "done":            break        parts = line.split()        if len(parts) != 5:            print("Error: expected exactly 5 fields.")            continue        subj, num, days_str, start_str, dur_str = parts        days_str = days_str.upper()        code = f"{subj} {num}"        try:            if not CRS_RE.fullmatch(subj) or not NUM_RE.fullmatch(num):                raise ValueError("course code malformed (e.g. MEEN 221 or ECEN 214L)")            if not DAYS_RE.fullmatch(days_str):                raise ValueError("days must be a non‑empty combo of MTWRF")            if not TIME_RE.fullmatch(start_str):                raise ValueError("start time must be HH:MM 24‑hour")            if not dur_str.isdigit() or int(dur_str) <= 0:                raise ValueError("duration must be a positive integer")            start_m = to_minutes(start_str)            if not (CLASS_MIN_START <= start_m <= CLASS_MAX_START):                raise ValueError("start time must be 08:00–16:10 inclusive")            duration = int(dur_str)        except ValueError as err:            print(f"Error: {err}")            continue        sections.setdefault(code, []).append((days_str, start_m, duration, code))        print("Success!")    if not sections:        print("\nNo sections entered; nothing to compute.")        return    # ---------- conflict detection -----------------------------------------    conflicts: Dict[str, List[Tuple[str, int]]] = {c: [] for c in sections}    all_secs = [sec for lst in sections.values() for sec in lst]    for i, sec_i in enumerate(all_secs):        days_i, start_i, dur_i, code_i = sec_i        for sec_j in all_secs[i + 1:]:            days_j, start_j, dur_j, code_j = sec_j            if code_i == code_j:                continue            if not set(days_i) & set(days_j):                continue            if overlaps((start_i, start_i + dur_i), (start_j, start_j + dur_j)):                conflicts[code_i].append((days_i, start_i))                conflicts[code_j].append((days_j, start_j))    # ---------- print conflicts earliest → latest --------------------------    conflict_entries = [        (start, code, days)        for code, lst in conflicts.items()        for days, start in lst    ]    if conflict_entries:        print("\nConflicting sections:")        for start, code, days in sorted(conflict_entries,                                        key=lambda x: (x[0], x[1], x[2])):            print(f"  {code}  {days}  {to_hhmm(start)}  (conflict)")    else:        print("\nAll sections are mutually compatible – no conflicts found.")    # ---------- pick one viable section/course for study‑slot grid ---------    accepted: Dict[str, Tuple[str, int, int]] = {}    busy_by_day = {d: [] for d in DAY_LETTERS}    for code in sorted(sections):        for days, st, dur, _ in sorted(sections[code], key=lambda x: x[1]):            interval = (st, st + dur)            if any(                overlaps(interval, iv)                for d in days                for iv in busy_by_day[d]            ):                continue            accepted[code] = (days, st, dur)            for d in days:                busy_by_day[d].append(interval)            break    busy_by_day = {d: merge(busy_by_day[d]) for d in DAY_LETTERS}    # ---------- study‑slot report per weekday ------------------------------    print("\n100‑minute meeting blocks (5‑min grid, start 08:00‑17:00):")    none_printed = True    for d in DAY_LETTERS:        free, best_start, min_cnt = free_and_min_conflict_slots(busy_by_day[d])        if free:            none_printed = False            print(f"{DAY_NAMES[d]}:")            for s, e in free:                print(f"  {to_hhmm(s)} – {to_hhmm(e)}")        else:            best_times = ", ".join(to_hhmm(s) for s in best_start)            print(                f"{DAY_NAMES[d]}:  no fully free slot; "                f"minimum conflicts = {min_cnt} at start {best_times}"            )    if none_printed and all(busy_by_day[d] for d in DAY_LETTERS):        print("  none")# ───────────────────────────────────────────────────────────────────────────if __name__ == "__main__":    main()